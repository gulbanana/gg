//! # GG: Gui for [JJ](https://jj-vcs.github.io/jj/)
//!
//! This crate exposes two ways to embed GG's functionality in your own application:
//!
//! ## Axum router (for embedding `gg web`)
//!
//! [`web::create_app`] returns an [`axum::Router`] that serves both the embedded
//! UI and a JSON API. This is the easiest integration path — you get a fully
//! working GG instance that can be composed with other Axum services or bound to
//! any [`tokio::net::TcpListener`].
//!
//! ## Worker session (for a custom embedding or use as an API)
//!
//! For lower-level control, create a [`worker::WorkerSession`] and drive it with
//! [`worker::SessionEvent`] messages over a standard [`std::sync::mpsc`] channel.
//! This is how both the Tauri GUI and the web server work internally — each
//! window/tab owns one worker thread because jj-lib is single-threaded.
//!
//! The worker thread is a state machine: [`worker::WorkerSession`] (unloaded) →
//! `WorkspaceSession` (loaded) → `QuerySession` (pagination). Only the first state
//! is public; transitions happen automatically in response to [`worker::SessionEvent`] messages.

pub mod config;
pub mod messages;
pub mod web;
pub mod worker;

// internal modules exposed for the binary, not part of the public API
#[doc(hidden)]
pub mod git_util;

pub use config::read_config;
use jj_lib::settings::UserSettings;
use std::path::PathBuf;

/// Configuration passed to [`web::create_app`] or the internal GUI launcher.
///
/// Use [`RunOptions::new`] for a simple starting point, or [`read_context`]
/// and [`read_config`] to put the pieces together yourself.
pub struct RunOptions {
    /// Tauri context generated by [`tauri::generate_context!`]. Contains the
    /// embedded frontend assets that the web server serves as static files.
    pub context: tauri::Context<tauri::Wry>,

    /// Jujutsu user settings (as seen in `jj config`).
    pub settings: UserSettings,

    /// Working directory to open on startup. When `None`, the worker falls
    /// back to the process's current directory (or `$OWD` on AppImage).
    pub workspace: Option<PathBuf>,

    /// Skip immutability checks on commits. Intended for testing or
    /// scripted workflows where the revset-based immutable set is too
    /// restrictive.
    pub ignore_immutable: bool,

    /// Enable verbose logging (`LevelFilter::Debug` for the `gg` target).
    #[doc(hidden)]
    pub debug: bool,

    /// Indicates this process was spawned by another GG instance. When `true`,
    /// the web server prints `"Startup complete."` to stdout so the parent
    /// knows the port is ready.
    #[doc(hidden)]
    pub is_child: bool,
}

impl RunOptions {
    /// Creates a `RunOptions` pointing at the given workspace directory.
    ///
    /// Loads Jujutsu settings from the standard config locations and generates
    /// a Tauri context. All boolean flags default to `false`.
    pub fn new(workspace: PathBuf) -> Self {
        let (settings, _, _) = read_config(Some(workspace.as_ref())).unwrap();
        let context = read_context();
        RunOptions {
            context,
            settings,
            workspace: Some(workspace),
            debug: false,
            is_child: false,
            ignore_immutable: false,
        }
    }
}

/// Load the context generated by [`tauri::generate_context!`], which contains the embedded frontend assets.
pub fn read_context() -> tauri::Context<tauri::Wry> {
    tauri::generate_context!()
}
