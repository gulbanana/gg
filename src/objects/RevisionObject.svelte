<script lang="ts">
    import { createEventDispatcher } from "svelte";
    import type { RevHeader } from "../messages/RevHeader";
    import type { Operand } from "../messages/Operand";
    import {
        currentTarget,
        revisionSelectEvent,
        currentRevisionSet,
        currentRevisionSetHex,
        currentSource,
    } from "../stores.js";
    import IdSpan from "../controls/IdSpan.svelte";
    import BranchObject from "./BranchObject.svelte";
    import Object from "./Object.svelte";
    import Zone from "./Zone.svelte";
    import RevisionMutator from "../mutators/RevisionMutator";
    import TagObject from "./TagObject.svelte";
    import AuthorSpan from "../controls/AuthorSpan.svelte";

    export let header: RevHeader;
    export let child: RevHeader | null = null;
    export let selected: boolean; // same as the imported event, but parent may want to force a value
    export let noBranches: boolean = false;

    const dispatch = createEventDispatcher();

    let operand: Operand = child ? { type: "Parent", header, child } : { type: "Revision", header };

    function onSelect(event: CustomEvent<MouseEvent>) {
        if (event.detail.ctrlKey) {
            if ($currentRevisionSet.has(header.id.change)) {
                $currentRevisionSet.delete(header.id.change);
            } else {
                $currentRevisionSet.add(header.id.change);
            }
            // The prefixes are subject to change as new revisions are added,
            // so they do not make for stable keys. However, we do want to
            // easily render the prefixes of the current set. So we keep a
            // parallel set of strings, and get the current prefixes from
            // the corresponding ChangeId objects.
            let hexes = new Set([...$currentRevisionSet].map(c => c.hex));
            currentRevisionSet.set($currentRevisionSet);
            currentRevisionSetHex.set(hexes);
        } else if (event.detail.shiftKey) {
            // It would probably be best to preserve & extend the current
            // revision set, but for now we'll just reset it to extend
            // from the original endpoint to the current object.
            console.log(`currentTarget = ${$currentTarget}`);
            console.log(`revisionSelectEvent = ${$revisionSelectEvent?.id.change.prefix}`);
            console.log(`currentSource = ${$currentSource}`);
            console.log(`header = ${header.id.change.prefix}`);
            const p0 = header.id.change.prefix;
            const p1 = $revisionSelectEvent?.id.change.prefix;
            if (p1) {
                // I guess the cleaner thing would be to query ancestor-vs-descendent
                // relations in each direction and emit the minimal applicable revset.
                // This is OK for a quick hack!
                const newrevsettext = `(${p0}::${p1} | ${p1}::${p0})`
                const revset_input = document.getElementById('revset') as HTMLInputElement;
                if (revset_input) {
                    revset_input.value = newrevsettext;
                    // event dispatching works in the common case when clicks
                    // are to revision objects in the log pane, but I think
                    // this won't work if the user shift-clicks revisions
                    // outside the log pane, e.g. parent revisions on the RHS.
                    dispatch('triggerUpdateRevisionSet', { revsetValue: newrevsettext });
                }
            }

            event.preventDefault();
        } else {
            revisionSelectEvent.set(header);
            currentRevisionSet.set(new Set([header.id.change]));
            currentRevisionSetHex.set(new Set([header.id.change.hex]));
        }
    }

    function onEdit() {
        new RevisionMutator(header).onEdit();
    }
</script>

<Object
    {operand}
    suffix={header.id.commit.prefix}
    conflicted={header.has_conflict}
    {selected}
    marked={$currentRevisionSetHex.has(header.id.change.hex)}
    label={header.description.lines[0]}
    on:click={onSelect}
    on:dblclick={onEdit}
    let:context
    let:hint={dragHint}>
    {#if child}
        <!-- Parents aren't a drop target -->
        <div class="layout">
            <IdSpan
                id={header.id.change}
                pronoun={context ||
                    ($currentTarget?.type == "Merge" &&
                        $currentTarget.header.parent_ids.findIndex((id) => id.hex == header.id.commit.hex) != -1)} />

            <span class="text desc truncate" class:indescribable={!context && header.description.lines[0] == ""}>
                {dragHint ?? (header.description.lines[0] == "" ? "(no description set)" : header.description.lines[0])}
            </span>

            <span class="email"><AuthorSpan author={header.author} /></span>

            <span class="refs">
                {#each header.refs as ref}
                    {#if ref.type != "Tag"}
                        {#if !noBranches && (ref.type == "LocalBookmark" || !ref.is_synced || !ref.is_tracked)}
                            <div>
                                <BranchObject {header} {ref} />
                            </div>
                        {/if}
                    {:else}
                        <div>
                            <TagObject {header} {ref} />
                        </div>
                    {/if}
                {/each}
            </span>
        </div>
    {:else}
        <Zone {operand} let:target let:hint={dropHint}>
            <div class="layout" class:target>
                <IdSpan id={header.id.change} pronoun={context || target || dropHint != null} />

                <span class="text desc truncate" class:indescribable={!context && header.description.lines[0] == ""}>
                    {dragHint ??
                        dropHint ??
                        (header.description.lines[0] == "" ? "(no description set)" : header.description.lines[0])}
                </span>

                <span class="email"><AuthorSpan author={header.author} /></span>

                <span class="refs">
                    {#each header.refs as ref}
                        {#if ref.type != "Tag"}
                            {#if ref.type == "LocalBookmark" || !ref.is_synced || !ref.is_tracked}
                                <div>
                                    <BranchObject {header} {ref} />
                                </div>
                            {/if}
                        {:else}
                            <div>
                                <TagObject {header} {ref} />
                            </div>
                        {/if}
                    {/each}
                </span>
            </div>
        </Zone>
    {/if}
</Object>

<style>
    .layout {
        pointer-events: auto;
        /* layout summary components along a text line */
        width: 100%;
        height: 30px;
        display: grid;
        grid-template-areas: ". desc refs";
        grid-template-columns: auto 1fr auto;
        align-items: baseline;
        gap: 6px;

        /* skip past svg lines when used in a graph */
        padding-left: var(--leftpad);
    }

    .layout.target {
        background: var(--ctp-flamingo);
        color: black;
    }

    .layout > :global(span) {
        line-height: 27px;
    }

    .desc {
        grid-area: desc;
    }

    .desc.indescribable {
        color: var(--ctp-subtext0);
    }

    .email {
        display: none;
        grid-area: email;
        text-align: right;
    }

    .refs {
        grid-area: refs;
        align-self: center;
        display: flex;
        justify-content: end;
        gap: 3px;
        color: var(--ctp-text);
    }

    /* multiple elements can have these */
    .truncate {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .text {
        pointer-events: none;
    }

    @media (width >= 1680px) {
        .layout {
            grid-template-areas: ". desc refs email";
            grid-template-columns: auto auto 1fr auto;
            gap: 9px;
        }

        .email {
            display: initial;
        }
    }
</style>
